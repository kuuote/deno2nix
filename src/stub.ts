export const stub =
  '{\n  pkgs ? import <nixpkgs> { },\n}:\nlet\n  inherit (pkgs)\n    lib\n    deno\n    ;\n  fetchJsr =\n    {\n      name,\n      version,\n      exports,\n      hash,\n    }:\n    {\n      "jsr.io/${name}/meta.json" = builtins.toFile "meta.json" "{\\"versions\\": {}}";\n      "jsr.io/${name}/${version}_meta.json" = builtins.fetchurl {\n        url = "https://jsr.io/${name}/${version}_meta.json";\n        sha256 = hash.meta;\n      };\n      "jsr.io/${name}/${version}" =\n        pkgs.runCommand "jsr:${name}@${version}"\n          {\n            outputHash = hash.src;\n            outputHashAlgo = "sha256";\n            outputHashMode = "nar";\n            inherit exports;\n          }\n          \'\'\n            export DENO_DIR=/tmp/deno\n            echo \'{"vendor": true}\' > deno.json\n            xargs ${lib.getExe deno} cache << EOS\n            ${lib.pipe exports [\n              (map (e: "jsr:${name}@${version}/${e}"))\n              (builtins.concatStringsSep "\\n")\n            ]}\n            EOS\n            cp -a vendor/jsr.io/${name}/${version} $out\n          \'\';\n    };\n  buildVendorDir =\n    data:\n    lib.pipe data.jsr [\n      (map fetchJsr)\n      lib.mergeAttrsList\n      (pkgs.linkFarm "vendor")\n    ];\n  fetchNpm =\n    m:\n    let\n      tgz = pkgs.fetchurl {\n        url = "https://registry.npmjs.org/${m.info.path}/-/${m.info.name}-${m.info.version}.tgz";\n        hash = m.integrity;\n      };\n    in\n    pkgs.runCommandLocal "npm:${m.info.path}@${m.info.version}" { } \'\'\n      mkdir dist\n      cd dist\n      tar xf ${tgz}\n      mkdir -p $out/node_modules/${m.info.path}\n      cp -a */* $out/node_modules/${m.info.path}/\n      ln -s ${tgz} $out/node_modules/${m.info.path}/_archive.tgz\n    \'\';\n  buildNodeModules =\n    data:\n    let\n      modules = builtins.mapAttrs (_: m: m // { src = fetchNpm m; }) data.npm;\n      withoutVersion = lib.mapAttrs\' (_: m: {\n        name = m.info.path;\n        value = m;\n      }) modules;\n      findDeps =\n        m:\n        map (d: modules.${d} or withoutVersion.${d}) (\n          [ "${m.info.path}@${m.info.version}" ] ++ m.dependencies or [ ]\n        );\n      genPaths =\n        mod:\n        let\n          plusName = builtins.replaceStrings [ "/" ] [ "+" ] "${mod.info.path}@${mod.info.version}";\n        in\n        lib.pipe mod [\n          findDeps\n          (map (m: {\n            name = ".deno/${plusName}/node_modules/${m.info.path}";\n            path = "${m.src}/node_modules/${m.info.path}";\n          }))\n        ];\n    in\n    lib.pipe modules [\n      builtins.attrValues\n      (map genPaths)\n      builtins.concatLists\n      (pkgs.linkFarm "node_modules")\n    ];\n  build = data: {\n    nodeModules = buildNodeModules data;\n    vendor = buildVendorDir data;\n  };\nin\nbuild\n';
